# -*- coding: utf-8 -*-
"""QTumi.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15_uQmNIK2317GJJ4OF_1vVvaWS-Y5kcj

# Quantum Optimization of Rural Hydro-Energy Distribution using QAOA
"""

!pip install qiskit==1.2.0 qiskit-algorithms qiskit-optimization scipy matplotlib

!pip install qiskit-aer

"""## Project Aim
To minimize infrastructure costs and improve planning of rural energy access in Ghana by partitioning the hydropower distribution using the Quantum Approximate Optimization Algorithm (QAOA).

We aim to help energy planners decide how to group towns and dams in a way that reduces the total length (or cost) of required connections, improving energy equity and advancing SDG 7: Affordable and Clean Energy.

## Why Quantum?
* The problem is modeled as a Max-Cut optimization (NP-hard).

* QAOA is a quantum-classical hybrid algorithm suited for such graph problems.

* It allows us to find high-quality approximate solutions faster than classical methods alone — especially as the network scales.

## Workflow of the Solution

### Step 1: Model the Network
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from qiskit import *
from qiskit_algorithms import QAOA
from qiskit.quantum_info import SparsePauliOp
from qiskit_algorithms.optimizers import COBYLA
from qiskit_algorithms.utils import algorithm_globals
from qiskit.primitives import Estimator, Sampler # Added Sampler here
from qiskit.visualization import plot_histogram
from itertools import combinations
from qiskit_algorithms.optimizers import SPSA
from qiskit_optimization.problems import QuadraticProgram # Added QuadraticProgram here
from qiskit_optimization.converters import QuadraticProgramToQubo
from qiskit_optimization.algorithms import MinimumEigenOptimizer
from qiskit_optimization import QuadraticProgram

from qiskit.primitives import StatevectorSampler
# Fixer la graine aléatoire
algorithm_globals.random_seed = 42

from google.colab import files
uploaded = files.upload()

import pandas as pd
import io

# Automatically read the uploaded CSV
filename = list(uploaded.keys())[0]
df = pd.read_csv(io.BytesIO(uploaded[filename]))

df.head()  # Show preview



import networkx as nx # Added import for networkx
from haversine import haversine # Added import for haversine

# === Build Efficiency Graph ===
towns = df['Town'].tolist()
Distance_km = df['Distance_km'].tolist() # Use latitudes from dataframe
longitudes = df['Longitude'].tolist() # Use longitudes from dataframe
demands = df['Final_Demand_kW'].tolist() # Use Final_Demand_kW from dataframe

G = nx.Graph()
for town in towns:
    G.add_node(town)

for i in range(len(towns)):
    for j in range(i + 1, len(towns)):
        # haversine expects tuples of (latitude, longitude)
        dist = haversine((latitudes[i], longitudes[i]), (latitudes[j], longitudes[j]))
        if dist != 0:
            avg_demand = (demands[i] + demands[j]) / 2
            weight = avg_demand / (2 * dist)
            G.add_edge(towns[i], towns[j], weight=weight)

# === Visualize Graph ===
pos = nx.spring_layout(G, seed=42)
plt.figure(figsize=(8, 6))
nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=1000, font_weight='bold')
edge_labels = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edge_labels(G, pos, edge_labels={k: f"{v:.0f}" for k, v in edge_labels.items()})
plt.title("Energy Efficiency Graph (Demand/Distance Weighted)")
plt.tight_layout()
plt.show()

# === Theoretical Minimum Calculation ===
min_unmet_possible = float('inf')
optimal_selection = None

print("\n=== Brute Force Solution (Verification) ===")
for r in range(n_qubits + 1):
    for subset in combinations(range(n_qubits), r):
        allocated = sum(demands[i] for i in subset)
        if allocated <= E_total:
            unmet = sum(demands[i] for i in range(n_qubits) if i not in subset)
            print(f"Select {[city_names[i] for i in subset]}: "
                  f"Allocated={allocated:.3f} kW, Unmet={unmet:.3f} kW")
            if unmet < min_unmet_possible:
                min_unmet_possible = unmet
                optimal_selection = subset

print(f"\nOptimal selection: {[city_names[i] for i in optimal_selection]}")
print(f"Minimum unmet demand: {min_unmet_possible:.3f} kW")

# === Problem Setup ===
demands = [306.257, 113.575, 161.751]  # kW demands for Tamale, Ho, Cape Coast
city_names = ['Tamale', 'Ho', 'Cape Coast']
E_total = 400  # Total available power in kW
n_qubits = len(demands)
total_demand = sum(demands)

print("=== Power Distribution Optimization Problem ===")
print(f"Cities: {city_names}")
print(f"Demands: {demands} kW")
print(f"Total demand: {total_demand:.3f} kW")
print(f"Available power: {E_total} kW")
print(f"Deficit: {total_demand - E_total:.3f} kW")

# === QUBO Hamiltonian Construction ===
print("\n=== QUBO Hamiltonian Construction ===")
# H = Σᵢ (dᵢ/2)(1 - Zᵢ) = Σᵢ (dᵢ/2) - Σᵢ (dᵢ/2)Zᵢ
# We minimize the second term (negative coefficients)

pauli_strings = []
for i in range(n_qubits):
    # Create Pauli string for Zᵢ
    pauli_str = ['I'] * n_qubits
    pauli_str[i] = 'Z'
    coeff = -demands[i] / 2  # Negative to minimize unmet demand
    pauli_strings.append((''.join(pauli_str), coeff))
    print(f"City {i} ({city_names[i]}): {pauli_str} with coefficient {coeff:.3f}")

# Add constant term (this doesn't affect optimization but helps with interpretation)
constant_term = sum(demands) / 2
hamiltonian = SparsePauliOp.from_list(pauli_strings)
print(f"Hamiltonian: {hamiltonian}")
print(f"Constant term (for interpretation): {constant_term:.3f}")

# === QAOA Circuit Construction ===
def create_qaoa_circuit(gamma, beta):
    """Create QAOA circuit with given parameters"""
    qc = QuantumCircuit(n_qubits, n_qubits)

    # Initial state: |+⟩⊗n (equal superposition)
    qc.h(range(n_qubits))
    qc.barrier()

    # QAOA layers
    for layer in range(len(gamma)):
        # Cost Hamiltonian: e^(-iγH_C)
        for i in range(n_qubits):
            qc.rz(2 * gamma[layer] * demands[i] / 2, i)  # RZ(2γ * coefficient)

        # Mixer Hamiltonian: e^(-iβH_M) where H_M = Σᵢ Xᵢ
        for i in range(n_qubits):
            qc.rx(2 * beta[layer], i)  # RX(2β)
    # Measurement
    qc.measure_all()

    return qc

# === QAOA Configuration ===
p = 6  # Number of layers
max_iterations = 300
shots = 500000

print(f"\n=== QAOA Configuration ===")
print(f"Number of layers (p): {p}")
print(f"Maximum iterations: {max_iterations}")
print(f"Number of shots: {shots}")

from qiskit.visualization import plot_circuit_layout
qc = create_qaoa_circuit([0.5], [0.3])  # Example parameters
qc.draw()  # Or use .draw('text') in CLI

# === Cost Function ===
def cost_function(bitstring):
    """Calculate cost for a given bitstring"""
    selected_cities = [i for i, bit in enumerate(bitstring) if bit == '1']
    allocated = sum(demands[i] for i in selected_cities)

    # Constraint: total allocation must not exceed available power
    if allocated > E_total:
        return float('inf')  # Invalid solution

    # Cost: unmet demand
    unmet = sum(demands[i] for i in range(n_qubits) if i not in selected_cities)
    return unmet

# === Callback for Tracking Progress ===
cost_history = []
iteration_count = 0

def callback(eval_count, parameters, mean, std):
    global iteration_count
    iteration_count += 1
    raw_cost = float(np.real(mean))

    # Normalize cost for better tracking
    if min_unmet_possible < total_demand:
        normalized_cost = (raw_cost + constant_term - min_unmet_possible) / (total_demand - min_unmet_possible)
    else:
        normalized_cost = raw_cost + constant_term

    cost_history.append(normalized_cost)

    if iteration_count % 10 == 0 or iteration_count <= 10:
        print(f"Iteration {iteration_count:03d}: Raw Cost = {raw_cost:.6f}, "
              f"Normalized = {normalized_cost:.6f}")

# === Run QAOA ===
print(f"\n=== Running QAOA ===")
print("Starting optimization...")

# Initialize optimizer
optimizer = COBYLA(maxiter=max_iterations)

# Create sampler
sampler = Sampler()

# Create QAOA instance
qaoa = QAOA(sampler=sampler, optimizer=optimizer, reps=p, callback=callback)

try:
    # Run optimization
    result = qaoa.compute_minimum_eigenvalue(hamiltonian)
    print(f"Optimization completed successfully!")

except Exception as e:
    print(f"Optimization interrupted: {e}")
    print("Using current best result...")

# === Analyze Results ===
print(f"\n=== QAOA Results Analysis ===")
print(f"Optimal value: {result.optimal_value:.6f}")
print(f"Optimal parameters: {result.optimal_point}")

# Get the quantum state and analyze
eigenstate = result.eigenstate
if hasattr(eigenstate, 'items'):
    # Extract probability distribution
    probs = {}
    for state, amplitude in eigenstate.items():
        prob = abs(amplitude) ** 2
        probs[state] = prob

    # Sort by probability
    sorted_states = sorted(probs.items(), key=lambda x: x[1], reverse=True)

    print(f"\nTop 5 most probable states:")
    for i, (state, prob) in enumerate(sorted_states[:5]):
        bitstring = format(state, f'0{n_qubits}b')
        selected_cities = [j for j, bit in enumerate(bitstring[::-1]) if bit == '1']
        city_selection = [city_names[j] for j in selected_cities]
        allocated = sum(demands[j] for j in selected_cities)
        unmet = sum(demands[j] for j in range(n_qubits) if j not in selected_cities)

        feasible = "✓" if allocated <= E_total else "✗"
        print(f"  {i+1}. |{bitstring}⟩ (prob={prob:.4f}) {feasible}")
        print(f"     Cities: {city_selection}")
        print(f"     Allocated: {allocated:.3f} kW, Unmet: {unmet:.3f} kW")

# === Find Best Valid Solution ===
print(f"\n=== Best Valid Solution ===")
best_cost = float('inf')
best_state = None
best_selection = None

if hasattr(eigenstate, 'items'):
    for state, amplitude in eigenstate.items():
        bitstring = format(state, f'0{n_qubits}b')
        selected_cities = [j for j, bit in enumerate(bitstring[::-1]) if bit == '1']
        allocated = sum(demands[j] for j in selected_cities)

        if allocated <= E_total:  # Valid solution
            unmet = sum(demands[j] for j in range(n_qubits) if j not in selected_cities)
            if unmet < best_cost:
                best_cost = unmet
                best_state = bitstring
                best_selection = selected_cities

if best_selection is not None:
    print(f"Best quantum solution:")
    print(f"  State: |{best_state}⟩")
    print(f"  Selected cities: {[city_names[i] for i in best_selection]}")
    print(f"  Allocated power: {sum(demands[i] for i in best_selection):.3f} kW")
    print(f"  Unmet demand: {best_cost:.3f} kW")
    print(f"  Matches optimal: {'Yes' if best_cost == min_unmet_possible else 'No'}")
else:
    print("No valid solution found in quantum result")

# === Visualize Convergence ===
if cost_history:
    plt.figure(figsize=(12, 8))

    # Plot 1: Cost evolution
    plt.subplot(2, 2, 1)
    plt.plot(cost_history, 'b-', linewidth=2, alpha=0.7)
    plt.axhline(y=0, color='r', linestyle='--', alpha=0.5, label='Optimal (normalized)')
    plt.xlabel('Iteration')
    plt.ylabel('Normalized Cost')
    plt.title('QAOA Convergence')
    plt.grid(True, alpha=0.3)
    plt.legend()



    # Plot 3: Problem visualization
    plt.subplot(2, 2, 3)
    cities = range(len(city_names))
    plt.bar(cities, demands, color=['#3498db', '#9b59b6', '#f39c12'], alpha=0.7)
    plt.axhline(y=E_total, color='red', linestyle='--', linewidth=2, label=f'Available: {E_total} kW')
    plt.xlabel('Cities')
    plt.ylabel('Power Demand (kW)')
    plt.title('Power Demands vs Available')
    plt.xticks(cities, city_names, rotation=45)
    plt.legend()
    plt.grid(True, alpha=0.3)

    # Plot 4: Solution comparison
    plt.subplot(2, 2, 4)
    if best_selection is not None:
        selected_demands = [demands[i] if i in best_selection else 0 for i in range(n_qubits)]
        unmet_demands = [demands[i] if i not in best_selection else 0 for i in range(n_qubits)]

        width = 0.35
        x = np.arange(len(city_names))
        plt.bar(x - width/2, selected_demands, width, label='Selected', color='green', alpha=0.7)
        plt.bar(x + width/2, unmet_demands, width, label='Unmet', color='red', alpha=0.7)
        plt.xlabel('Cities')
        plt.ylabel('Power (kW)')
        plt.title('QAOA Solution')
        plt.xticks(x, city_names, rotation=45)
        plt.legend()
        plt.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.show()

# === Summary ===
print(f"\n=== Summary ===")
print(f"Problem: Minimize unmet power demand under constraint")
print(f"Method: QAOA with {p} layers, {max_iterations} iterations")
print(f"Theoretical optimum: {min_unmet_possible:.3f} kW unmet")
if best_selection is not None:
    print(f"QAOA result: {best_cost:.3f} kW unmet")
    print(f"Gap from optimum: {best_cost - min_unmet_possible:.3f} kW")
    print(f"Success: {'Yes' if abs(best_cost - min_unmet_possible) < 0.001 else 'Partial'}")
else:
    print("QAOA result: No valid solution found")
print(f"Total iterations: {len(cost_history)}")

"""## Project Workflow

**Aim**: Minimise the cost of rural Hydro-energy access in Ghana

Step 1: Define energy network (nodes and edges) \\
Step 2: Construct the graph and get the adjacency matrix \\
Step 3: Construct Max-cut Hamiltonian \\
Step 4: Define the mixer hamiltonian ($H_{M}$) \\
Step 5: Build QAOA unsat quantum circuit \\
Step 6: Expectation evaluation function  \\
Step 7: Optimise parameters --> Optimal parameters --> Solution \\
Step 8: Interprete and Visualise results
"""

!pip install haversine